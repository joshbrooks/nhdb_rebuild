// Generated by CoffeeScript 1.10.0

/* RequestTag coffeescript/js code */

(function() {
  var self;

  self = this;

  self.message = 'Requests';

  self.online_status = 'online';

  self.requestCounts = {};

  self.requests = [];


  /* Just test if our store is available */

  self.ping = function(e) {
    console.log('ping');
    return console.log(e);
  };


  /* Update requestCounts, a hash of request properties, with the number of requests meeting criteria */

  self.requestStats = function(fieldname) {
    var i, len, r, ref, request, value;
    r = {};
    ref = self.requests;
    for (i = 0, len = ref.length; i < len; i++) {
      request = ref[i];
      value = request[fieldname] || 'undefined';
      r[value] = (r[value] || 0) + 1;
    }
    return self.requestCounts[fieldname] = r;
  };


  /* Upon mounting this tag, retrieve requests from localStorage */

  self.on('mount', function() {
    return RiotControl.trigger('unshelve_requests');
  });

  RiotControl.on('requests_changed', function(requests) {
    var i, len, request;
    self.requests = requests;
    console.log(requests);
    for (i = 0, len = requests.length; i < len; i++) {
      request = requests[i];
      console.log(request.action);
      if (request.action === 'immediate' && request.status === 0) {
        request.action = 'inprogress';
        RiotControl.trigger('request_do', request);
      }
    }
    self.requestStats('status');
    self.requestStats('method');
    self.requestStats('modelName');
    return self.update();
  });

  RiotControl.on('request_failed', function(request, jqXHR, textStatus, errorThrown) {
    request.status = jqXHR.status;
    self.update();
    console.log(jqXHR);
    console.log(textStatus);
    return console.log(errorThrown);
  });

  RiotControl.on('request_add', function() {
    return self.update();
  });


  /* Show requests with only a give status or method */

  self.updateFiltering = function() {
    var filter;
    filter = $(self.filtering).val();
    return RiotControl.trigger('updateRequestFiltering', filter);
  };

  self.clearRequests = function() {
    var filter;
    filter = $(self.clearing).val();
    console.log('clearRequests');
    console.log(filter);
    return RiotControl.trigger('clearRequests', filter);
  };

  self.showAllRequests = function() {
    return self.setPropertyByPropertyRange('status', -1, -1, 'hidden');
  };

  self.doAllRequests = function() {
    var i, len, ref, ref1, request, results;
    console.log('doAllRequests');
    ref = self.requests;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      request = ref[i];
      if (!((200 < (ref1 = request.status) && ref1 <= 400))) {
        results.push(RiotControl.trigger('request_do', request));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };


  /* Functions which can be provided by the tag as events, ie onclick={ ... } */

  self.request_do = function(e) {
    return RiotControl.trigger('request_do', e.item);
  };

  self.request_remove = function(e) {
    return RiotControl.trigger('request_remove', e);
  };

  self.shelve_requests = function() {
    return RiotControl.trigger('shelve_requests');
  };

  self.unshelve_requests = function() {
    return RiotControl.trigger('unshelve_requests');
  };

  self.clearSuccessfulRequests = function() {
    return self.requests = self.requests.filterByPropertyRange(200, 300);
  };

  self.clearBadRequests = function() {
    return self.requests = self.requests.filterByPropertyRange(400, 500);
  };

}).call(this);
